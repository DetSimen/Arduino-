класс TTimerList.

Просматривая форумы хоббистов и фанатов Arduino я удивился, что 50% вопросов новичков - о том как избавиться от функции delay() в своих программах.  По некоторому размышлению, у меня возникла идея создать список асинхронных таймеров, которые можно настроить на разные длительности (от 1 миллисекунды до почти 50 суток).  Один 16-разрядный аппаратный таймер, на Uno это Timer1, на Mega2560 - это Timer5, настраивается на срабатывание каждую миллисекунду и вызывает метод статического класса TTimerList.  Класс содержит список Items типа 

	struct TCallStruct				// внутренняя структура для хранения КАЖДОГО таймера
	{
	 PVoidFunc	CallingFunc;			// функция, которую нужно вызвать при срабатывании
	 long		InitCounter;			// заданное кол-во миллисекунд
	 long		WorkingCounter;			// рабочий счетчик. после начала счёта сюда копируется значение из InitCounter
	 bool           Active;	  			// и каждую миллисекунду уменьшается на 1. При достиженнии 0 вызывается функция 
						        // CallingFunc, и снова записывается значение из InitCounter. Счёт начинается сначала. :)
	};

Пробегая по списку, каждую миллисекунду класс уменьшает на 1 рабочий счетчик каждого добавленного таймера (у которого CallingFunc != NULL) и который запущен (Active==true). Усли рабочий счетчик достиг нуля, вызывается функция CallingFunc описанная как void CallingFunc(void). После этого в рабочий счетчик загружается значение из InitCounter и счет начинается сначала.

Использование: скопировать два файла uTimerList cpp и h в директорию с рабочим проектом, подключить через #include "uTimerList.h". Обязательно объявить глобально extern TTimerList TimerList; и можно добавлять, удалять, останавливать и снова запускать таймеры асинхронно.
Для Uno список может содержать 8 таймеров, для 2560 - 16. Если таймеров нужно больше, исправить строчку 

 	#define     MAXTIMERSCOUNT		8		
 
 в файле uTimerList.h на нужное количество таймеров.  
 
    	THandle      Add(PVoidFunc AFunc, long timeMS);	        // функция AFunc, которую надо вызвать через timeMS миллисекунд

 
 функция Add добавляет таймер в список и сразу же запускает его, принимает адрес функции, которую нужно вызвать.
 вызываемая функция описана как void f(void). При добавлении таймера, функцию в Add подставляем просто по имени, без скобок. Если подставить со скобками - компилятор сделает вызов функции, если без скобок - передаст адрес функции как параметр, что и нужно по смыслу. 
 
 Add(...)  отдает так называемый хэндл, идентификатор таймера, по которому его можно удалить, остановить и запустить вновь. По смыслу это обычный номер в списке, то так как добавление идёт не подряд, а на свободное место, то он может быть каким угодно, если планируется останавливать и удалять таймер, лучше запоминать этот номер. 
 
 Полностью рабочий блинк без delay() и millis():
 
	
#include "uTimerList.h"

	extern TTimerList TimerList;

	THandle hnd_blink;
	THandle hnd_error;

	byte    normalLedPin = 13   // сюда подключим зеленый светодиод, который будет просто моргать
	byte    errorLedPin = 10;   // сюда подключим красный светодиод, сигнализирующий, например, об ошибке

	void setup() 
	{
  	 pinMode(errorLedPin,OUTPUT);
  	 pinMode(normalLedPin,OUTPUT);
  	 
	 hnd_blink = TimerList.AddSeconds(OKBlink,1); // добавляем таймер, задержка между морганиями 1 секунда, вызывается OKBlink
  	 hnd_error = TimerList.Add(ErrorBlink,250);   // добавляем таймер, моргаем 2 раза в секунду, вызывается ErrorBlink
  
	}

	void OKBlink(void)    // функция вызывается раз в секунду
	{
  	 static bool state=true;
  	 digitalWrite(normalLedPin, state);
  	 state = ! state;
	}

	void ErrorBlink(void)  // функция вызывается раз в 250 миллисекунд.
	{
  	 static bool state=true;
  	 digitalWrite(errorLedPin, state);
  	 state = ! state;
	}


	void loop() 
	{
  		// здесь даже писать ничего не надо, всё мигает отоматически

	}



Список таймеров удобен, например, когда нужно опрашивать датчики асинхронно, независимо друг от друга и с разными интервалами. 

другие функции списка

   	THandle      Add(PVoidFunc AFunc, long timeMS);	        // функция AFunc, которую надо вызвать через timeMS миллисекунд
	THandle      AddSeconds(PVoidFunc AFunc, word timeSec); // то же, только интервал задается в секундах. 
	THandle      AddMinutes(PVoidFunc AFunc, word timeMin); // то же, только интервал задается в минутах. 
                        	                                // исключительно для удобства создания длинных интервалов 

	bool     CanAdd();                          // если можно добавить таймер, вернет true

	bool	 IsActive();                        // true, если хоть один таймер запущен

	void	 Delete(THandle hnd);               // удалить таймер hnd

	void	 Start();                           // запустить рабочий цикл перебора таймеров

	void	 Stop();                            // TimerList выключен, все таймеры остановлены

	byte	 Count();                           // счетчик добавленных таймеров, всего. 
                                                    //Можно не использовать, просто проверять возможность
	                                            // добавления, вызывая ф-цию CanAdd();

	void    TimerStop(THandle hnd);            // остановить отдельный таймер по его хэндлу

	void    TimerStart(THandle hnd);           // запустить отдельный таймер (после остановки) 
		                                   //счет не продолжается, а начинается сначала



код хорошо (надеюсь) комментирован, изучайте. 

Если кому то это настольно понравились и пригодилось, что он готов расстаться с деньгами, можно перечислить несколько денег 
на мой модемный счёт +79139403924.  Обращаю внимание - счёт модемный, звонить на него бесполезно, связаться со мной по вопросам можно по электропочте dap68@mail.ru  или по аське ICQ 394705231.
