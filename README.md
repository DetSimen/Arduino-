класс TTimerList.

Просматривая форумы хоббистов и фанатов Arduino я удивился, что 50% вопросов новичков - о том как избавиться от функции delay() в своих программах.  По некоторому размышлению, у меня возникла идея создать список асинхронных таймеров, которые можно настроить на разные длительности (от 1 миллисекунды до почти 50 суток).  Один 16-разрядный аппаратный таймер, на Uno это Timer1, на Mega2560 - это Timer5, настраивается на срабатывание каждую миллисекунду и вызывает метод статического класса TTimerList. 

(По многочисленным просьбам трудящихся, переделал на Timer0, освободив 16-разрядный таймер, скоро выложу, на 328 камне еще не протестировал, на 2560 работает точно. Правда, для точности в 1 мс, пришлось пожертвовать точностью millis(), она теперь врёть процентов на 3. Следите за правками. 

Так вот, класс содержит список Items типа 

	struct TCallStruct				// внутренняя структура для хранения КАЖДОГО таймера
	{
	 PVoidFunc	CallingFunc;			// функция, которую нужно вызвать при срабатывании
	 long		InitCounter;			// заданное кол-во миллисекунд
	 long		WorkingCounter;			// рабочий счетчик. после начала счёта сюда копируется значение из InitCounter
	 bool           Active;	  			// и каждую миллисекунду уменьшается на 1. При достиженнии 0 вызывается функция 
						        // CallingFunc, и снова записывается значение из InitCounter. Счёт начинается сначала. :)
	};

Пробегая по списку, каждую миллисекунду класс уменьшает на 1 рабочий счетчик каждого добавленного таймера (у которого CallingFunc != NULL) и который запущен (Active==true). Если рабочий счетчик достиг нуля, вызывается функция CallingFunc описанная как

	using PVoidFunc = void (*)(void);  указатель на функцию без параметров ничего не возвращающую.
	
После этого в рабочий счетчик загружается значение из InitCounter и счет начинается сначала. Прерывания запрещаются на время перебора таймеров в списке. 

Использование: 

скопировать два файла uTimerList cpp и h в директорию с рабочим проектом, подключить через #include "uTimerList.h". Обязательно объявить глобально 

	extern TTimerList TimerList; 

и можно добавлять, удалять, останавливать и снова запускать таймеры асинхронно.
Для Uno список может содержать 8 таймеров, для 2560 - 16. Если таймеров нужно больше, исправить строчку 

 	#define     MAXTIMERSCOUNT		8		
 
 в файле uTimerList.h на нужное количество таймеров.  
 
    	THandle      Add(PVoidFunc AFunc, long timeMS);	        // функция AFunc, которую надо вызвать через timeMS миллисекунд

 
 функция Add добавляет таймер в список и сразу же запускает его, принимает адрес функции, которую нужно вызвать.
 вызываемая функция описана как void (*)(void). При добавлении таймера, функцию в Add подставляем просто по имени, без скобок. Если подставить со скобками - компилятор сделает вызов функции, если без скобок - передаст адрес функции как параметр, что и нужно по смыслу. 
 
 Add(...)  отдает так называемый хэндл, идентификатор таймера, по которому его можно удалить, остановить и запустить вновь. По смыслу это обычный номер в списке, но так как добавление идёт не подряд, а на свободное место, то он может быть каким угодно, если планируется останавливать и удалять таймер, лучше этот номер запоминать. 
 
 Полностью рабочий блинк без delay() и millis()  (да и без loop()) :)
 
	
#include "uTimerList.h"

	extern TTimerList TimerList;

	THandle hnd_blink;          // хэндл для светодиода на ноге 13
	THandle hnd_error;          // хэндл для светодиода на ноге 10

	byte    normalLedPin = 13   // сюда подключим зеленый светодиод, который будет просто моргать
	byte    errorLedPin = 10;   // сюда подключим красный светодиод, сигнализирующий, например, об ошибке

	void setup() 
	{
  	 pinMode(errorLedPin,OUTPUT);
  	 pinMode(normalLedPin,OUTPUT);
  	 
	 hnd_blink = TimerList.AddSeconds(OKBlink,1); // добавляем таймер, задержка между морганиями 1 секунда, вызывается OKBlink
  	 hnd_error = TimerList.Add(ErrorBlink,250);   // добавляем таймер, моргаем 2 раза в секунду, вызывается ErrorBlink
  
	}

	void OKBlink(void)    // функция вызывается раз в секунду
	{
  	 static bool state=true;
  	 digitalWrite(normalLedPin, state);
  	 state = ! state;
	}

	void ErrorBlink(void)  // функция вызывается раз в 250 миллисекунд.
	{
  	 static bool state=true;
  	 digitalWrite(errorLedPin, state);
  	 state = ! state;
	}


	void loop() 
	{
  		// здесь даже писать ничего не надо, всё мигает отоматически

	}


Даже если нужно чтоб интервалы были неравномерные, например, светодиод горит 50 миллисекунд, а не горит - 5 секунд (быстро мигает раз
в 5 секунд, для индикации нормальной работы), то и это можно легко сделать одним таймером:

Объявляем глобально переменную-хэндл:

	THandle hLEDBlink;

в setup() создаем таймер 

	hLEDBlink=TimerList.AddSeconds(tmrLEDBlink,1); // пока ставим интервал раз в секунду, потом изменим
	
и в функции отклика tmrLEDBlink() пишем: 

	void tmrLEDBlink()
	{
	 static bool ledstate = false;	  // статическая переменная хранит предыдущее состояние светодиода
	 ledstate = !ledstate;		  // инвертируем состояние светодиода 	
	 digitalWrite(ledpin, ledstate);  // пишем новое состояние в порт (зажигаем/гасим светодиод)
	 TimerList.TimerNewInterval(hLEDBlink, ledstate ? 50 : 4950); // устанавливаем новый интервал для таймера hLEDBlink
        }						              // гореть он будет 50мс, не гореть - 4950мс. 		


Список таймеров удобен, например, когда нужно опрашивать датчики асинхронно, независимо друг от друга и с разными интервалами.
Например, чтоб читать датчик DHT11 раз в минуту, надо создать функцию 
	
	void readDHT(void); 

и добавить в список таймеров

	THandle hnd_dht = TimerList.AddMinutes(readDHT, 1);  // 1 раз в минуту
	
всё, раз в минуту будет вызываться readDHT, потом его можно остановить

	TimerList.TimerStop(hnd_dht)
	
или удалить

	TimerList.Delete(hnd_dht);
	
тогда readDHT() вызываться не будет.

Вот все полезные функции списка таймеров: 

   	THandle      Add(PVoidFunc AFunc, long timeMS);	        // функция AFunc, которую надо вызвать через timeMS миллисекунд
	THandle      AddSeconds(PVoidFunc AFunc, word timeSec); // то же, только интервал задается в секундах. 
	THandle      AddMinutes(PVoidFunc AFunc, word timeMin); // то же, только интервал задается в минутах. 
                        	                                // исключительно для удобства создания длинных интервалов 

	bool     CanAdd();                          // если можно добавить таймер, вернет true

	bool	 IsActive();                        // true, если хоть один таймер запущен

	void	 Delete(THandle hnd);               // удалить таймер hnd

	void	 Start();                           // запустить рабочий цикл перебора таймеров

	void	 Stop();                            // TimerList выключен, все таймеры остановлены

	byte	 Count();                           // счетчик добавленных таймеров, всего. 
                                                    //Можно не использовать, просто проверять возможность
	                                            // добавления, вызывая ф-цию CanAdd();

	void    TimerStop(THandle hnd);            // остановить отдельный таймер по его хэндлу

	void    TimerStart(THandle hnd);           // запустить отдельный таймер (после остановки) 
		                                   //счет не продолжается, а начинается сначала
	
	void    TimerNewInterval(THandle hnd, long newinterval); // назначить таймеру hnd новый интервал



код хорошо (надеюсь) комментирован, изучайте. 

Cвязаться со мной по вопросам можно по электропочте dap68@mail.ru  или по аське ICQ 394705231.
